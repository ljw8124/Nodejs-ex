# 웹소켓을 이용한 채팅 구현
- <b>요청에 대해서만 응답하는 HTTP 통신</b></br>
웹은 HTTP 프로토콜 위에서 동자갛기 때문에 요청을 보내야지만, 응답을 보내준다. -> 양방향 통신을 지원하지 않음


- <b>주기적으로 요청을 보내서 응답을 받는 폴링 방식</b></br>
화면 갱신없이 실시간성을 가지기 위해서는 웹소켓을 이용하면 된다.</br>
하지만 웹소켓 이전에는 폴링/롱폴링 이라는 방법을 이용하였는데, 폴링은 주기적으로 요청을 보내는 방식이고 롱폴링은 클라이언트와 서버 간의 커넥션을 유지한 상태로 응답을 주고받는 방식이다.</br>
따라서 폴링/롱폴링은 둘 다 클라이언트가 서버에게 요청을 보내야한다.


- <b>양방향 통신이 가능한 웹소켓</b></br>
웹소켓의 특징은 두가지가 있는데, 그 중 하나는 양방향 통신이라는 것이다. 이는 데이터의 송수신을 동시에 처리한다는 것을 의미한다.</br>
즉 클라이언트와 서버가 원하는 때 데이터를 주고받을 수 있다는 의미이다.</br>
두 번째는 실시간 네트워킹을 구현하는 것이 용이하다는 것이다. 브로드캐스팅을 지원하므로 여러 클라이언트와 빠르게 데이터를 교환할 수 있어 편리하다.


### 웹소켓 동작방법
웹소켓 프로토콜은 크게 핸드 쉐이크와 데이터 전송으로 나눌 수 있다.</br>
핸드 쉐이크는 서버와 클라이언트가 커넥션을 맺는 과정으로써 최초 한 번만 실행된다.</br>
이때는 HTTP 1.1 프로토콜을 사용하고 헤더에 Upgrade:websocket 과 Connection: Upgrade 를 추가해서 웹소켓 프로토콜을 사용하도록 한다.</br>


작동 과정: 1단계 최초 HTTP 으로 핸드쉐이크 - 2단계: 웹소켓으로 양방향 통신 - 3단계: 접속 끊

1단계. 핸드쉐이크 시에 클라이언트가 서버에 보내는 데이터
```
    GET /chat HTTP/1.1
    HOST: server.example.com
    Upgrade: websocket      // 현재 프로토콜에서 다른 프로토콜로 업그레이드하라는 규칙
    Connection: Upgrade     // Upgrade 필드가 있으면 반드시 같이 명시
    Sec-WebSocket-Key: dGHlIHNhbXBsZSBub25jZQ==     // 클라이언트 키 예시
    Origin: http://example.com      // 필수 항목, 클라이언트 주소 예시
    Sec-WebSocket-Protocol: caht, superchat
    Sec-WebSocket-Version: 13       // 클라이언트가 요청하는 하위 프로토콜
```


2단계. 위 요청을 받은 후 서버는 응답으로 아래 데이터를 넘겨준다
```
    HTTP/1.1 101 Switching Protocols        // 연결성공
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+x0o=     // 클라이언트로부터 받은 키를 사용해 계산된 값
     Sec-WebSocket-Protocol: chat
```

여기서 받은 데이터를 메시지라 부르며 메시지는 프레임의 모음이다. 프레임은 바이트의 배열이다.</br>
프레임은 헤더와 페이로드로 이루어져 있다.</br>
헤더는 FIN, RSV1~3, 오프코드, 마스크, 페이로드 길이, 마스킹 키 가 있다.


3단계. 접속을 끊는다. 접속은 클라이언트와 서버 양쪽에서 모두 끊을 수 있고, opcode 에 1000을 담아서 보내준다.


### 웹소켓은 데이터를 전장하는 것만 지원할 뿐 전송된 데이터로 무엇을 구현할지는 개발자의 몫이라고 할 수 있다.


## NestJS 에서 채팅구현
기존 처럼 네스트 프로젝트를 생성하고, 필요한 패키지 설치

```
$ npm i @nestjs/websockets @nestjs/platform-socket.io
$ npm i -D @types/socket.io 
```
NestJS 에서 웹소켓을 사용한 통신을 받아주는 클래스를 게이트웨이라고 한다.</br>
게이트웨이를 활용하면 의존성 주입, 데코레이터, 필터, 카드 등의 NestJS 기능을 사용할 수 있다.</br>


간단히 말해서 프로토콜이 HTTP 라면 컨트롤러로부터 요청을 받고, 프로토콜이 ws 라면 게이트웨이로부터 요청을 받는 차이이다.


게이트 파일 수동으로 생성
```
$ nest g gateway chat
```

socket.io 는 채팅방을 만드는 room 기능을 제공한다.</br>
채팅방별로 메시지를 통신해야 하므로 네임스페이스도 같이 사용하는데, 네임스페이스는 지정된 곳에만 이벤트를 발생시키고 메시지를 전송하는 개념이다(멀티플렉싱이라고도 함)</br>
네임스페이스와 룸을 같이 사용함으로써 더 정교하게 메시지 송수신을 제어할 수 있다.

