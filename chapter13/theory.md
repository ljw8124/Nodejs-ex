# 웹소켓을 이용한 채팅 구현
- <b>요청에 대해서만 응답하는 HTTP 통신</b></br>
웹은 HTTP 프로토콜 위에서 동자갛기 때문에 요청을 보내야지만, 응답을 보내준다. -> 양방향 통신을 지원하지 않음


- <b>주기적으로 요청을 보내서 응답을 받는 폴링 방식</b></br>
화면 갱신없이 실시간성을 가지기 위해서는 웹소켓을 이용하면 된다.</br>
하지만 웹소켓 이전에는 폴링/롱폴링 이라는 방법을 이용하였는데, 폴링은 주기적으로 요청을 보내는 방식이고 롱폴링은 클라이언트와 서버 간의 커넥션을 유지한 상태로 응답을 주고받는 방식이다.</br>
따라서 폴링/롱폴링은 둘 다 클라이언트가 서버에게 요청을 보내야한다.


- <b>양방향 통신이 가능한 웹소켓</b></br>
웹소켓의 특징은 두가지가 있는데, 그 중 하나는 양방향 통신이라는 것이다. 이는 데이터의 송수신을 동시에 처리한다는 것을 의미한다.</br>
즉 클라이언트와 서버가 원하는 때 데이터를 주고받을 수 있다는 의미이다.</br>
두 번째는 실시간 네트워킹을 구현하는 것이 용이하다는 것이다. 브로드캐스팅을 지원하므로 여러 클라이언트와 빠르게 데이터를 교환할 수 있어 편리하다.


### 웹소켓 동작방법
웹소켓 프로토콜은 크게 핸드 쉐이크와 데이터 전송으로 나눌 수 있다.</br>
핸드 쉐이크는 서버와 클라이언트가 커넥션을 맺는 과정으로써 최초 한 번만 실행된다.</br>
이때는 HTTP 1.1 프로토콜을 사용하고 헤더에 Upgrade:websocket 과 Connection: Upgrade 를 추가해서 웹소켓 프로토콜을 사용하도록 한다.</br>


작동 과정: 1단계 최초 HTTP 으로 핸드쉐이크 - 2단계: 웹소켓으로 양방향 통신 - 3단계: 접속 끊

1단계. 핸드쉐이크 시에 클라이언트가 서버에 보내는 데이터
```
    GET /chat HTTP/1.1
    HOST: server.example.com
    Upgrade: websocket      // 현재 프로토콜에서 다른 프로토콜로 업그레이드하라는 규칙
    Connection: Upgrade     // Upgrade 필드가 있으면 반드시 같이 명시
    Sec-WebSocket-Key: dGHlIHNhbXBsZSBub25jZQ==     // 클라이언트 키 예시
    Origin: http://example.com      // 필수 항목, 클라이언트 주소 예시
    Sec-WebSocket-Protocol: caht, superchat
    Sec-WebSocket-Version: 13       // 클라이언트가 요청하는 하위 프로토콜
```


2단계. 위 요청을 받은 후 서버는 응답으로 아래 데이터를 넘겨준다
```
    HTTP/1.1 101 Switching Protocols        // 연결성공
     Upgrade: websocket
     Connection: Upgrade
     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+x0o=     // 클라이언트로부터 받은 키를 사용해 계산된 값
     Sec-WebSocket-Protocol: chat
```

여기서 받은 데이터를 메시지라 부르며 메시지는 프레임의 모음이다. 프레임은 바이트의 배열이다.</br>
프레임은 헤더와 페이로드로 이루어져 있다.</br>
헤더는 FIN, RSV1~3, 오프코드, 마스크, 페이로드 길이, 마스킹 키 가 있다.


3단계. 접속을 끊는다. 접속은 클라이언트와 서버 양쪽에서 모두 끊을 수 있고, opcode 에 1000을 담아서 보내준다.


### 웹소켓은 데이터를 전장하는 것만 지원할 뿐 전송된 데이터로 무엇을 구현할지는 개발자의 몫이라고 할 수 있다.