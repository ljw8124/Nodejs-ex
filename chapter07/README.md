# NESTJS
NestJS 는 JS 최신 기능을 사용하는 웹 프레임워크이다.</br>
좋은 구조로 애플리케이션을 작성해 프로젝트의 복잡성을 잘 관리하는 것을 목표로 한다.

### 특징
- Node.js 에서 실행하는 서버 사이드 프레임워크이다.
- 타입스크립트를 완벽하게 지원한다.
- JS 의 최신스펙을 사용한다. 그러므로 바닐라 JS 를 사용하려면 babel 사용이 필수이다.
- HTTP 요청 부분은 추상화된 코드를 제공해 익스프레스와 패스티파이를 사용할 수 있다. (패스트파이: 고성능, 확장성, 스키마기반, 로깅, 개발자 친화적)

서버 개발에 아키텍처가 필요한 이유는, 쉽게 테스트하고 쉽게 확장이 가능하고 각 모듈간의 의존성을 줄이도록 해야 유지보수가 쉽기 때문이다.

NestJS 의 핵심은 의존성 주입이다. 의존성을 주입함으로서 모듈 간의 결합도를 낮춰서 코드의 재사용을 용이하게 하기 때문이다. </br>
즉, 모듈 내에서의 코드의 응집도는 높여서 모듈의 재사용을 꾀하고 모듈 간에는 결합도를 낮춰서 다양한 아키텍처에서 활용할 수 있게 해준다.

NestJS 에서는 HTTP 요청을 보통 파이프 -> 가드 -> 콘트롤러 -> 서비스 -> 리포지토리 순서로 처리한다.</br>
이중 컨트롤러는 필수적이라고 할 수 있다. 클라이언트에서 온 요청을 코드에 전달해야 하기 때문이다.</br>
또한 컨트롤러는 모듈에 포함되어 있으므로 NestJS 를 최소한의 코드로 실행시키려면 하나의 모듈과 하나의 컨트롤러가 필요하다.

### 설치방법
1. NestJS 구동에 필요한 라이브러리들을 모두 수동으로 설치하는 방법
2. nest-cli 패키지를 이용하는 방법. nest 명령어를 사용하여 쉽게 프로젝트를 생성할 수 있다.
3. nest 명령어를 설치하는 저장소를 직접 git clone 하여 개발 디렉터리에 내려받은 후 설정하는 방법

### package-json 구조 설명
- @nestjs/common -> NestJS 의 공통 코드들
- @nestjs/core -> NestJS 의 핵심 코드(가드, 미들웨어, 파이프 등);
- @nestjs/platform-express -> HTTP 요청에 익스프레스 사용
- reflect-metadata -> 데코레이터 사용 시 필수
- typescript -> 타입스크립트 사용 시 필수

### NestJS 네이밍 규칙
1. 파일명은 . 으로 연결한다. 모듈이 둘 이상의 단어로 구성되어 있으면 대시로 연결한다</br>
ex) <모듈명>.<컴포넌트명>.ts => my-first.controller.ts
2. 클래스명은 낙타표기법을 사용한다.</br>
ex) <모듈명><컴포넌트명> => HelloController
3. 같은 디렉터리에 있는 클래스는 index.ts 를 통해서 임포트하는 것을 권장한다.
4. 타입스크립트에서는 인터페이스를 많이 사용하므로, 인터페이스는 타입을 정의하는데 사용되고 구체적인 내용은 클래스를 만들고 인터페이스를 상속받는 방식으로 작성한다.</br>
인터페이스 작명법으로 앞에 I 를 붙이는 방법도 있다. ex) Series 를 ISeries 로 작성</br>
그렇기 때문에 NestJS 에서는 인터페이스를 만들고 그 하위 인터페이스 혹은 클래스를 만든다.</br>
```
 // ex)
 interface Series {}
 interface BookSeries extends Series {}
 class MovieSeries extends Series {}
```

## 개발 프로세스
1. API 만들기 (프로젝트 생성 -> 컨트롤러 생성 -> 블로그 API 작성 -> 메모리와 파일로 블로그 API 만들기)
2. 의존성 주입 (의존성 주입 설정 -> 서비스에 리포지토리 의존성 주입하기 -> 컨트롤러에 서비스 의존성 주입)
3. 몽고디비 연동하기 (의존성 설치 -> 스키마 만들기 -> 몽고디비 리포지토리 생성 -> 서비스에서 몽고디비를 사용하도록 변경)

nest-cli 설치 -> $ npm install -g @nestjs/cli

프로젝트 생성 -> nest new blog

.prettierrc 는 코드 포매팅 관련 설정 파일이다.

nest-cli.json 파일은 nest 명령어를 사용해 프로젝트를 생성하거나 파일을 생성할 때 필요에 따라 수정한다.

app.controller.spec.ts 는 컨트롤러 테스트를 위한 파일이다. NestJS 에서는 jest 와 supertest 를 사용해 테스트한다.

### 컨트롤러 만들기
NestJS 에는 수많은 컴포넌트가 있는데, 그 중 컨트롤러는 유저가 보낸 HTTP 요청을 어떤 코드에서 처리할지 정하는 역할을 한다.

### 유효성 검증
NestJS 에서는 유효성 검증을 파이프를 사용해서 한다. (익스프레스는 별도의 라이브러리 이용)</br>
ValidationPipe 이용 -> class-validator 와 class-transformer 설치 필요
- class-validator: 데코레이터를 사용해 간편하게 유효성 검증을 하는 라이브러리
- class-transformer: JSON 정보를 클래스 객체로 변경한다. 받은 요청을 변환한 클래스가 컨트롤러의 핸들러 메서드의 매개변수에 선언되어 있는 클래스와 같다면, 유효성 검증을 한다.

```
$ npm i install class-validator class-transformer
```
### 인증 모듈과 회원가입
인증 방식은 두 가지가 있다. 쿠키 & 토큰 이용, 쿠키는 서버에서 보내준 쿠키를 클라이언트(브라우저)에 저장해 관리한다.</br>
토큰은 서버에 상태를 저정할 필요가 없습니다. 쿠키와 토큰은 서로 장단점이 있으니 요구사항에 다라 선택할 사항이다.

- [쿠키]</br>
하위 도메인에서 같은 세션을 사용할 수 있음</br>
저장 공간을 적게 차지함</br>
브라우저에서 관리함</br>
httpOnly 설정을 하면 클라이언트에서 자바스크립트로 조작할 수 있음</br>
사이트 간 위조공격(cors) 공격에 취약하고 서버에 저장해야하므로 스케일링 이슈가 있음. API 인증으로는 좋지 않음</br>
=> 브라우저에서 관리해준다.


- [토큰]</br>
유연하며 사용이 간단함</br>
크로스 플랫폼 대응</br>
다양한 프론트 엔드 애플리케이션에서 대응</br>
토큰 누출 시 권한 삭제가 어려움. 거부 목록을 따로 관리해야 하는데 그러면 무상태가 아니게 된다. 쿠키보다 공간을 더 차지하게 된다</br>
JWT 내부 정보는 토큰 생성 시의 데이터이므로 최신 데이터를 반영하지 않을 수 있다</br>
=> 커스텀 HTTP 헤더 사용(주로 Authorization)


### 회원가입
패스워드를 암호화하기 위해서 bcrypt 를 이용한다.</br>
웹스톰에서는 Database Tools and SQL for Webstorm 플러그인을 이용하면 웹스톰 내에서 볼 수 있다.

### 쿠키를 사용한 인증
NestJS 에서 인증을 구현할 때에는 보통 인증용 미들웨어인 가드(Guard)를 사용함</br>
가드는 특정 상황(권한, 롤, 엑세스컨트롤)에서 받은 요청을 가드를 추가한 라우트 메서드에서 처리할지 말지 결정하는 역할을 한다.
```
# 서버측에서 HTTP 요청의 헤더에 있는 쿠키를 읽는 코드가 필요 -> 유저 인증 정보를 확인하기 위해서
$ npm install cookie-parser
```

쿠키 파서는 쿠키를 Request 객체에서 읽어오는데 사용하는 미들웨어이다.

### 패스포트와 세션을 사용한 인증
쿠키만으로 인증을 하게되면 위변조와 탈취의 위험에서 자유롭지 못하게 된다.</br>
이 문제를 해결할 좋은 방법은 서버에서 인증을 하고 해당 정보를 서버의 특정 공간에 저장해두는 것 이다.</br>
이 때 세션과 쿠키를 이용하는데, 쿠키는 세션을 찾는 정보만 저장하고 중요 정보는 세션에 모두 넣어두는 것이다.</br>
세션은 서버에 부하를 준다는 단점이 있지만 위조, 변조, 탈취가 불가능하므로 보안적으로는 더 안전하다고 할 수 있다.

### OAuth
Open Authorization 의 약자로 구글과 트위터가 만든 개방형 인가의 표준이다.</br>
소셜 로그인 기능을 제공한다.

- 인증: 리소스에 접근 자격이 있는지 검증하는 과정
- 인가: 자원에 접근할 권한을 부여하는 과정 -> 인가가 완료되면 리소스의 접근 권한 정보가 있는 엑세스 토큰을 클라이언트에게 보내준다.
- 엑세스 토큰: 리소스 서버에서 리소스 소유자의 보호된 정보를 획득할 때 사용하는 만료 기간이 있는 토큰
- 리프레시 토큰: 엑세스 토큰이 만료되었을 때 갱신하는 용도로 사용하는 토큰
- 리소스 소유자: 리소스는 사용자의 보호된 정보를 말하며 이런 정보에 접근하도록 자격을 부여하는 사람을 ㅁ라한다
- 클라이언트: 리소스를 사용하려고 접근을 요청하는 애플리케이션
- 리소스 서버: 사용자의 보호된 자원을 가지고 있는 서버
- 인가 서버: 인증/인가를 수행하는 서버로 클라이언트의 접근 자격을 확인하고 엑세스 토큰을 발급해 권한을 부여한다.

인가 서버와 리소스 서버의 조합을 OAuth2 프로바이더라고 부르기도 한다.

#### OAuth 프로토콜 흐름
1. 인가요청
2. 인가 승인 요청
3. (2) 에서 받은 정보로 엑세스 토큰 요구
4. 엑세스 토큰 발급
5. 엑세스 토큰으로 보호된 자원 요청
6. 보호된 자원의 정보를 내려줌

#### 엑세스 토큰을 재발행하는 흐름
1. 인가승인
2. 엑세스 토큰과 리프레시 토큰을 발급
3. 엑세스 토큰 전달
4. 보호된 리소스를 내려줌
5. 만료된 엑세스 토큰 전달
6. 유효하지 않은 토큰 에러
7. 리프레시 토큰 전달
8. 새로운 엑세스 토큰(옵션: 리프레시 토큰) 발장


## File upload
```
$ npm i -D @types/multer
```
파일업로드를 위한 패키지 설치 (타입정보가 있다면 더욱 안전한 코딩이 가능하다)

FileInterceptor 는 첫 번째 인수로 폼 필드의 이름을 넣고, 두 번째 인수로는 어디에 저장할지, 어떤 파일의 형식을 허용할지, 파일명은 변경할지, 크기는 얼마까지 허용할지 등의 옵션을 제공한다.
- storage: 파일이 저장 될 위치 및 파일 이름 제어
- fileFilter: 어떤 형식의 파일을 허용할지 제어
- limits: 필드명, 값, 파일 개수, 파일 용량, multipart 폼의 인수 개수, 헤더 개수 제한 설정
- preservePath: 파일의 전체 경로를 유지할지 여부

디스크에 파일을 저장해야 하므로 storage 를 이용하는데, storage 는 diskStorage() 와 memoryStorage() 가 있다.</br>
아무 설정도 하지 않으면 memoryStorage() 를 사용하고 이 때 파일 속성은 buffer 이다. 따라서 메모리가 기본 값이다.

디스크를 사용하는 diskStorage() 는 buffer 속성을 가지고 있지 않으므로 제거해야 한다.</br>
즉, 디스크에 저장하는 옵션을 활성화하고 메모리를 사용하는 코드를 작성해야 한다.
